// Run this using "make compat-table"
const fs = require('fs')
const path = require('path')
const stage1to3 = require('../github/compat-table/data-esnext')
const stage4 = require('../github/compat-table/data-es2016plus')
const environments = require('../github/compat-table/environments.json')
const interpolateAllResults = require('../github/compat-table/build-utils/interpolate-all-results')

interpolateAllResults(stage1to3.tests, environments)
interpolateAllResults(stage4.tests, environments)

const features = {
  'exponentiation (**) operator': { target: 'ExponentOperator' },
  'nested rest destructuring, declarations': { target: 'NestedRestBinding' },
  'nested rest destructuring, parameters': { target: 'NestedRestBinding' },
  'async functions': { target: 'Async' },
  'object rest/spread properties': { target: 'ObjectRestSpread' },
  'Asynchronous Iterators': { target: 'AsyncIter' },
  'optional catch binding': { target: 'OptionalCatchBinding' },
  'BigInt: basic functionality': { target: 'BigInt' },
  'optional chaining operator (?.)': { target: 'OptionalChain' },
  'nullish coalescing operator (??)': { target: 'NullishCoalescing' },
  'Logical Assignment': { target: 'LogicalAssignment' },
  'Hashbang Grammar': { target: 'Hashbang' },

  // Public fields
  'instance class fields: public instance class fields': { target: 'ClassField' },
  'instance class fields: computed instance class fields': { target: 'ClassField' },
  'static class fields: public static class fields': { target: 'ClassStaticField' },
  'static class fields: computed static class fields': { target: 'ClassStaticField' },

  // Private fields
  'instance class fields: private instance class fields basic support': { target: 'ClassPrivateField' },
  'instance class fields: private instance class fields initializers': { target: 'ClassPrivateField' },
  'instance class fields: optional private instance class fields access': { target: 'ClassPrivateField' },
  'instance class fields: optional deep private instance class fields access': { target: 'ClassPrivateField' },
  'static class fields: private static class fields': { target: 'ClassPrivateStaticField' },

  // Private methods
  'private class methods: private instance methods': { target: 'ClassPrivateMethod' },
  'private class methods: private accessor properties': { target: 'ClassPrivateMethod' },
  'private class methods: private static methods': { target: 'ClassPrivateStaticMethod' },
  'private class methods: private static accessor properties': { target: 'ClassPrivateStaticMethod' },
}

const versions = {}
const engines = [
  'android',
  'chrome',
  'edge',
  'es',
  'firefox',
  'ios',
  'node',
  'safari',
]

function mergeVersions(target, res) {
  const map = versions[target] || (versions[target] = {})
  for (const key in res) {
    if (res[key] === true) {
      const engine = /^[a-z]*/.exec(key)[0]
      if (engines.indexOf(engine) >= 0) {
        const version = +key.slice(engine.length).replace('_', '.')
        map[engine] = Math.min(version, map[engine] || Infinity)
      }
    }
  }
}

mergeVersions('Async', { es2017: true })
mergeVersions('AsyncIter', { es2018: true })
mergeVersions('BigInt', { es2020: true })
mergeVersions('ExponentOperator', { es2016: true })
mergeVersions('NestedRestBinding', { es2016: true })
mergeVersions('NullishCoalescing', { es2020: true })
mergeVersions('ObjectRestSpread', { es2018: true })
mergeVersions('OptionalCatchBinding', { es2019: true })
mergeVersions('OptionalChain', { es2020: true })

for (const test of stage4.tests.concat(stage1to3.tests)) {
  const feature = features[test.name]
  if (feature) {
    feature.found = true
    if (test.subtests) {
      for (const subtest of test.subtests) {
        mergeVersions(feature.target, subtest.res)
      }
    } else {
      mergeVersions(feature.target, test.res)
    }
  } else if (test.subtests) {
    for (const subtest of test.subtests) {
      const feature = features[`${test.name}: ${subtest.name}`]
      if (feature) {
        feature.found = true
        mergeVersions(feature.target, subtest.res)
      }
    }
  }
}

for (const feature in features) {
  if (!features[feature].found) {
    throw new Error(`Did not find ${feature}`)
  }
}

function upper(text) {
  if (text === 'es' || text === 'ios') return text.toUpperCase()
  return text[0].toUpperCase() + text.slice(1)
}

function writeInnerMap(obj) {
  const keys = Object.keys(obj).sort()
  const maxLength = keys.reduce((a, b) => Math.max(a, b.length + 1), 0)
  return keys.map(x => `\t\t${(upper(x) + ':').padEnd(maxLength)} ${obj[x]},`).join('\n')
}

fs.writeFileSync(__dirname + '/../internal/compat/table.go',
  `// This file was automatically generated by "${path.basename(__filename)}"

package compat

type Engine uint8

const (
${engines.map((x, i) => `\t${upper(x)}${i ? '' : ' Engine = iota'}`).join('\n')}
)

type Feature uint32

const (
${Object.keys(versions).sort().map((x, i) => `\t${x}${i ? '' : ' Feature = 1 << iota'}`).join('\n')}
)

var Table = map[Feature]map[Engine]float32{
${Object.keys(versions).sort().map(x => `\t${x}: map[Engine]float32{
${writeInnerMap(versions[x])}
\t},`).join('\n')}
}
`)

// console.log(versions)
